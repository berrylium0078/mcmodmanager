"""
Mason version support
Generated by Claude Sonnet 4.5
"""
import json
import zipfile
import toml
import tempfile
import re
from pathlib import Path
from typing import List, Optional
from dataclasses import dataclass, field
from enum import Enum

class ModLoader(Enum):
    FORGE = "forge"
    NEOFORGE = "neoforge"
    FABRIC = "fabric"
    QUILT = "quilt"
    LITELOADER = "liteloader"
    CAULDRON = "cauldron"


# Special mod IDs that represent the game/loader itself
SPECIAL_MODS = {
    'minecraft',
    'forge',
    'neoforge',
    'fabricloader', 'fabric-loader', 'fabric',
    'quilt_loader', 'quilt',
    'liteloader',
    'cauldron',
    'java',
    'fml'  # Forge Mod Loader
}


@dataclass
class Dependency:
    mod_id: str
    version_range: str = "*"
    mandatory: bool = True
    ordering: str = "NONE"
    is_special: bool = False  # For minecraft, forge, fabric, etc.


@dataclass
class ModInfo:
    mod_id: str
    name: str
    version: str
    loader: ModLoader
    dependencies: List[Dependency] = field(default_factory=list)
    provides: List[str] = field(default_factory=list)
    file_path: Optional[Path] = None
    is_jar_in_jar: bool = False
    parent_mod: Optional[str] = None


class ModParser:
    """Parse mod metadata from various mod loaders"""
    
    @staticmethod
    def parse_mod_file(file_path: Path) -> List[ModInfo]:
        """
        Parse a mod JAR file and extract metadata.
        Returns a list of ModInfo (main mod + any nested Jar-in-Jar mods)
        """
        mods = []
        
        try:
            with zipfile.ZipFile(file_path, 'r') as jar:
                # Parse main mod
                main_mod = ModParser._parse_main_mod(jar, file_path)
                if main_mod:
                    mods.append(main_mod)
                
                # Extract and parse nested JARs if enabled
                if main_mod:
                    nested_mods = ModParser._extract_jar_in_jar(jar, file_path, main_mod)
                    mods.extend(nested_mods)
            if mods:
                return mods
                
        except Exception as e:
            print(f'exception: {e}')
            pass

        print(f"Error parsing {file_path.name}")
        # If no mods parsed, try to extract from filename
        fallback_mod = ModParser._parse_from_filename(file_path)
        if fallback_mod:
            mods.append(fallback_mod)

        return mods

    @staticmethod
    def _parse_manifest(jar: zipfile.ZipFile, file_path: Path) -> Optional[str]:

        try:
            with jar.open('META-INF/MANIFEST.MF') as manifest_file:
                for line in manifest_file:
                    line = line.decode('utf-8').strip()
                    if line.startswith('Implementation-Version:'):
                        return line.split(':', 1)[1].strip()
            print(f"No Implementation-Version found in {file_path} MANIFEST.MF.")
            return None
        except KeyError:
            print(f"No MANIFEST.MF found in {file_path}.")
            return None

    @staticmethod
    def _parse_from_filename(file_path: Path) -> Optional[ModInfo]:
        """
        Try to extract mod ID and version from filename.
        Common patterns: modid-version.jar, modid_version.jar, modid-mc1.19.2-version.jar
        """
        name = file_path.stem  # Remove .jar
        
        # Try common patterns
        patterns = [
            r'^(.+?)[-_](\d+(?:\.\d+)*(?:[-+].+?)?)$',  # modid-1.2.3 or modid_1.2.3
            r'^(.+?)[-_]mc\d+\.\d+(?:\.\d+)?[-_](\d+(?:\.\d+)*(?:[-+].+?)?)$',  # modid-mc1.19.2-1.2.3
            r'^(.+?)[-_](?:forge|fabric|quilt)[-_](\d+(?:\.\d+)*(?:[-+].+?)?)$',  # modid-forge-1.2.3
        ]
        
        for pattern in patterns:
            match = re.match(pattern, name)
            if match:
                mod_id = match.group(1).lower().replace('-', '_').replace(' ', '_')
                version = match.group(2)
                
                return ModInfo(
                    mod_id=mod_id,
                    name=match.group(1),
                    version=version,
                    loader=ModLoader.FORGE,  # Unknown, default to Forge
                    file_path=file_path
                )
        
        # Fallback: use entire filename as mod_id
        print(f"Warning: Could not parse version from filename: {file_path.name}")
        return ModInfo(
            mod_id=name.lower().replace('-', '_').replace(' ', '_'),
            name=name,
            version="unknown",
            loader=ModLoader.FORGE,
            file_path=file_path
        )
    
    @staticmethod
    def _parse_main_mod(jar: zipfile.ZipFile, file_path: Path) -> Optional[ModInfo]:
        """Parse the main mod from a JAR file"""
        # Try Forge/NeoForge (mods.toml)
        result = None
        if 'META-INF/mods.toml' in jar.namelist():
            result = ModParser._parse_forge_neoforge(jar, file_path)
        # Try Fabric/Quilt (fabric.mod.json)
        elif 'fabric.mod.json' in jar.namelist():
            result = ModParser._parse_fabric_quilt(jar, file_path)
        # Try old Forge (mcmod.info)
        elif 'mcmod.info' in jar.namelist():
            result = ModParser._parse_old_forge(jar, file_path)
        # Try LiteLoader (litemod.json)
        elif 'litemod.json' in jar.namelist():
            result = ModParser._parse_liteloader(jar, file_path)

        if not result:
            return ModParser._parse_from_filename(file_path)
        
        if result.version == '${file.jarVersion}':
            result.version = ModParser._parse_manifest(jar, file_path) or "unknown"
        if result.version.startswith('v'):
            result.version = result.version[1:]
        return result
    
    @staticmethod
    def _extract_jar_in_jar(jar: zipfile.ZipFile, parent_path: Path, parent_mod: ModInfo) -> List[ModInfo]:
        """
        Extract and parse nested JAR files (Jar-in-Jar).
        Common locations:
        - META-INF/jarjar/ (Forge/NeoForge)
        - META-INF/jars/ (Fabric/Quilt)
        """
        nested_mods = []
        parent_name = parent_mod.name if parent_mod else parent_path.stem
        
        # Look for nested JARs in common locations
        nested_jar_paths = []
        for name in jar.namelist():
            if name.endswith('.jar') and (
                name.startswith('META-INF/jarjar/') or
                '/jars/' in name
            ):
                nested_jar_paths.append(name)
        
        print(nested_jar_paths)
        if not nested_jar_paths:
            return nested_mods
        
        # Create temp directory for extraction
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            for nested_jar_path in nested_jar_paths:
                try:
                    # Extract nested JAR
                    jar.extract(nested_jar_path, temp_path)
                    extracted_path = temp_path / nested_jar_path
                    
                    # Parse the nested JAR
                    nested_jar_mods = ModParser.parse_mod_file(extracted_path)
                    
                    for nested_mod in nested_jar_mods:
                        nested_mod.is_jar_in_jar = True
                        nested_mod.parent_mod = parent_name
                        nested_mod.file_path = parent_path  # Reference parent file
                        nested_mods.append(nested_mod)
                        
                except Exception as e:
                    print(f"Warning: Failed to parse nested JAR {nested_jar_path}: {e}")
        
        return nested_mods

    @staticmethod
    def _resolve_placeholder(value: str, jar: zipfile.ZipFile, file_path: Path) -> str:
        """
        Resolve placeholders like ${file.jarVersion} in metadata.
        """
        if not value or '${' not in value:
            return value
        
        # ${file.jarVersion} - extract from jar manifest
        if '${file.jarVersion}' in value:
            try:
                manifest = jar.read('META-INF/MANIFEST.MF').decode('utf-8')
                for line in manifest.split('\n'):
                    if line.startswith('Implementation-Version:'):
                        version = line.split(':', 1)[1].strip()
                        value = value.replace('${file.jarVersion}', version)
                        return value
            except:
                pass
            
            # Fallback: try to extract from filename
            match = re.search(r'[-_](\d+(?:\.\d+)*(?:[-+].+?)?)\.jar$', file_path.name)
            if match:
                value = value.replace('${file.jarVersion}', match.group(1))
        
        return value
    
    @staticmethod
    def _parse_forge_neoforge(jar: zipfile.ZipFile, file_path: Path) -> Optional[ModInfo]:
        """Parse Forge/NeoForge mods.toml"""
        content = jar.read('META-INF/mods.toml').decode('utf-8')
        data = toml.loads(content)
        
        # Determine if it's NeoForge or Forge
        loader_str = data.get('loaderVersion', '')
        loader = ModLoader.NEOFORGE if 'neoforge' in loader_str.lower() else ModLoader.FORGE
        
        # Get first mod entry
        mods = data.get('mods', [])
        if not mods:
            return None
        
        mod = mods[0]
        mod_id = mod.get('modId', 'unknown')
        name = mod.get('displayName', mod_id)
        version = mod.get('version', '0.0.0')
        
        # Parse dependencies
        dependencies = []
        for dep in data.get('dependencies', {}).get(mod_id, []):
            dep_mod_id = dep.get('modId', '')
            dependencies.append(Dependency(
                mod_id=dep_mod_id,
                version_range=dep.get('versionRange', '*'),
                mandatory=dep.get('mandatory', True),
                ordering=dep.get('ordering', 'NONE'),
                is_special=dep_mod_id.lower() in SPECIAL_MODS,
            ))
        
        return ModInfo(
            mod_id=mod_id,
            name=name,
            version=version,
            loader=loader,
            dependencies=dependencies,
            file_path=file_path
        )
    
    @staticmethod
    def _parse_fabric_quilt(jar: zipfile.ZipFile, file_path: Path) -> ModInfo:
        """Parse Fabric/Quilt fabric.mod.json"""
        content = jar.read('fabric.mod.json').decode('utf-8')
        data = json.loads(content)
        
        mod_id = data.get('id', 'unknown')
        name = data.get('name', mod_id)
        version = data.get('version', '0.0.0')
        
        # Check if it's Quilt (has quilt_loader in depends)
        depends = data.get('depends', {})
        loader = ModLoader.QUILT if 'quilt_loader' in depends else ModLoader.FABRIC
        
        # Parse dependencies
        dependencies = []
        for dep_id, dep_version in depends.items():
            dependencies.append(Dependency(
                mod_id=dep_id,
                version_range=dep_version if isinstance(dep_version, str) else '*',
                mandatory=True,
                is_special=dep_id.lower() in SPECIAL_MODS,
            ))
        
        # Parse provides
        provides = data.get('provides', [])
        
        return ModInfo(
            mod_id=mod_id,
            name=name,
            version=version,
            loader=loader,
            dependencies=dependencies,
            provides=provides,
            file_path=file_path
        )
    
    @staticmethod
    def _parse_old_forge(jar: zipfile.ZipFile, file_path: Path) -> ModInfo:
        """Parse old Forge mcmod.info"""
        content = jar.read('mcmod.info').decode('utf-8')
        data = json.loads(content)
        
        if isinstance(data, list):
            data = data[0]
        
        mod_id = data.get('modid', 'unknown')
        name = data.get('name', mod_id)
        version = data.get('version', '0.0.0')
        
        # Parse dependencies
        dependencies = []
        for dep in data.get('requiredMods', []):
            dependencies.append(Dependency(
                mod_id=dep,
                mandatory=True,
                is_special=dep.lower() in SPECIAL_MODS,
            ))
        
        return ModInfo(
            mod_id=mod_id,
            name=name,
            version=version,
            loader=ModLoader.FORGE,
            dependencies=dependencies,
            file_path=file_path
        )
    
    @staticmethod
    def _parse_liteloader(jar: zipfile.ZipFile, file_path: Path) -> ModInfo:
        """Parse LiteLoader litemod.json"""
        content = jar.read('litemod.json').decode('utf-8')
        data = json.loads(content)
        
        mod_id = data.get('name', 'unknown')
        name = data.get('displayName', mod_id)
        version = data.get('version', '0.0.0')
        
        # LiteLoader doesn't typically have complex dependency definitions
        dependencies = []
        for dep in data.get('requiredMods', []):
            dependencies.append(Dependency(
                mod_id=dep,
                mandatory=True,
                is_special=dep.lower() in SPECIAL_MODS,
            ))
        
        return ModInfo(
            mod_id=mod_id,
            name=name,
            version=version,
            loader=ModLoader.LITELOADER,
            dependencies=dependencies,
            file_path=file_path
        )
