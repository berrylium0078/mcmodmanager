"""
Maven Version String Library

Implements Maven's version ordering and version range parsing according to:
https://maven.apache.org/pom.html
- "Dependency Version Requirement Specification"
- "Version Order Specification"

Mostly generated by Claude Sonnet 4.5
"""

from typing import List, Tuple, Union, Optional
from dataclasses import dataclass

class MavenVersion:
    """
    Represents a Maven version string and implements Maven's version ordering rules.
    
    Maven version comparison follows these rules:
    1. Versions are split into tokens at '.', '-', '_', and digit/char transitions
    2. Trailing "null" values (0, "", "final", "ga", "release") are trimmed
    3. Tokens are compared left to right
    4. Numeric tokens are compared as integers
    5. Qualifiers have special ordering: alpha < beta < milestone < rc/cr < snapshot < "" < sp
    """
    
    # Special qualifiers with defined ordering
    SPECIAL_QUALIFIERS = {
        "alpha": 1, "a": 1,
        "beta": 2, "b": 2,
        "milestone": 3, "m": 3,
        "rc": 4, "cr": 4,
        "snapshot": 5,
        "": 6, "final": 6, "ga": 6, "release": 6,
        "sp": 7
    }
    
    # Null values that should be trimmed
    NULL_VALUES = {0, "", "final", "ga", "release"}
    
    def __init__(self, version_string: str):
        """
        Initialize a MavenVersion from a version string.
        
        Args:
            version_string: The version string to parse
        """
        self.original = version_string
        self.tokens = self._parse(version_string)
    
    def _parse(self, version: str) -> List[Tuple[str, Union[int, str]]]:
        """
        Parse a version string into a list of (separator, value) tuples.
        
        Returns:
            List of (separator, value) where separator is '.' or '-' and value is int or str
        """
        if not version:
            return [(".", "")]
        
        # Split into tokens
        tokens = []
        current_token = ""
        last_was_digit = None
        separator = "."
        
        for i, char in enumerate(version):
            if char in ".-_":
                if current_token or (i == 0):
                    tokens.append((separator, current_token))
                    current_token = ""
                separator = "-" if char == "-" else "."
                last_was_digit = None
            else:
                is_digit = char.isdigit()
                # Transition between digit and char acts as hyphen
                if last_was_digit is not None and last_was_digit != is_digit:
                    tokens.append((separator, current_token))
                    current_token = char
                    separator = "-"
                else:
                    current_token += char
                last_was_digit = is_digit
        
        # Add last token
        if current_token or not tokens:
            tokens.append((separator, current_token))
        
        # Replace empty tokens with "0"
        tokens = [(sep, tok if tok else "0") for sep, tok in tokens]
        
        # Convert numeric tokens to integers
        result = []
        for sep, tok in tokens:
            try:
                result.append((sep, int(tok)))
            except ValueError:
                result.append((sep, tok.lower()))
        
        # Trim trailing nulls
        result = self._trim_nulls(result)
        
        return result if result else [(".", "")]
    
    def _trim_nulls(self, tokens: List[Tuple[str, Union[int, str]]]) -> List[Tuple[str, Union[int, str]]]:
        """
        Trim trailing null values and recursively trim at each hyphen from end to start.
        """

        is_trailing_null = True
        for i in range(len(tokens) - 1, -1, -1):
            sep, val = tokens[i]
            is_trailing_null = is_trailing_null and val in self.NULL_VALUES
            if is_trailing_null:
                tokens[i] = ('', '') # mark for deletion

            if sep == '-':
                is_trailing_null = True

        tokens = [(sep, val) for sep, val in tokens if sep]
        return tokens
    
    def _pad_tokens(self, other_tokens: List[Tuple[str, Union[int, str]]]) -> Tuple[List[Tuple[str, Union[int, str]]], List[Tuple[str, Union[int, str]]]]:
        """
        Pad the shorter token list to match the longer one.
        Padding uses 0 for '.' separator and "" for '-' separator.
        """
        tokens1 = self.tokens[:]
        tokens2 = other_tokens[:]
        
        while len(tokens1) < len(tokens2):
            # Determine padding based on other version's separator
            other_sep, _ = tokens2[len(tokens1)]
            pad_value = 0 if other_sep == "." else ""
            # Use the same separator as the corresponding token in other
            tokens1.append((other_sep, pad_value))
        
        while len(tokens2) < len(tokens1):
            my_sep, _ = tokens1[len(tokens2)]
            pad_value = 0 if my_sep == "." else ""
            tokens2.append((my_sep, pad_value))
        
        return tokens1, tokens2
    
    def _compare_token(self, tok1: Tuple[str, Union[int, str]], tok2: Tuple[str, Union[int, str]]) -> int:
        """
        Compare two tokens according to Maven rules.
        
        Returns:
            -1 if tok1 < tok2, 0 if equal, 1 if tok1 > tok2
        """
        sep1, val1 = tok1
        sep2, val2 = tok2
        
        # If separators are different, handle special cases
        if sep1 != sep2:
            # . = - for qualifiers, but . > - for numbers
            if isinstance(val1, str) and isinstance(val2, str):
                # ".qualifier" = "-qualifier"
                pass  # Continue to value comparison
            elif isinstance(val1, int) and isinstance(val2, str):
                # "-number" < ".number" but also "-qualifier" < "-number"
                # Since we have mixed types: number on left, qualifier on right
                # This means: ".number" > "-qualifier"
                return 1 if sep1 == "." else -1
            elif isinstance(val1, str) and isinstance(val2, int):
                # "-qualifier" < ".number"
                return -1 if sep1 == "-" else 1
            else:
                # Both numbers: ".number" > "-number"
                if sep1 == ".":
                    return 1
                else:
                    return -1
        
        # Compare values
        if isinstance(val1, int) and isinstance(val2, int):
            if val1 < val2:
                return -1
            elif val1 > val2:
                return 1
            else:
                return 0
        
        # At least one is a qualifier
        if isinstance(val1, str) and isinstance(val2, int):
            # Qualifiers come before numbers (when same separator)
            return -1
        elif isinstance(val1, int) and isinstance(val2, str):
            return 1
        else:
            # Both are qualifiers
            return self._compare_qualifiers(str(val1), str(val2))
    
    def _compare_qualifiers(self, q1: str, q2: str) -> int:
        """
        Compare two qualifier strings according to Maven rules.
        """
        # Check if they're special qualifiers
        special1 = self._get_special_qualifier_order(q1)
        special2 = self._get_special_qualifier_order(q2)
        
        if special1 is not None and special2 is not None:
            if special1 < special2:
                return -1
            elif special1 > special2:
                return 1
            else:
                return 0
        elif special1 is not None:
            # q1 is special, q2 is not
            # Special qualifiers (except "sp") come before regular qualifiers
            if special1 < self.SPECIAL_QUALIFIERS[""]:  # Before empty string
                return -1
            else:
                return 1
        elif special2 is not None:
            # q2 is special, q1 is not
            if special2 < self.SPECIAL_QUALIFIERS[""]:
                return 1
            else:
                return -1
        else:
            # Both are regular qualifiers - case insensitive string comparison
            if q1 < q2:
                return -1
            elif q1 > q2:
                return 1
            else:
                return 0
    
    def _get_special_qualifier_order(self, qualifier: str) -> Optional[int]:
        """
        Get the order number for a special qualifier, or None if not special.
        """
        # Check for shorthand followed by number (e.g., "a1" -> "alpha")
        if len(qualifier) >= 2:
            first_char = qualifier[0]
            if first_char in {'a', 'b', 'm'} and qualifier[1:].isdigit():
                return self.SPECIAL_QUALIFIERS.get(first_char)
        
        return self.SPECIAL_QUALIFIERS.get(qualifier)
    
    def __lt__(self, other: 'MavenVersion') -> bool:
        return self._compare(other) < 0
    def __le__(self, other: 'MavenVersion') -> bool:
        return self._compare(other) <= 0
    def __gt__(self, other: 'MavenVersion') -> bool:
        return self._compare(other) > 0
    def __ge__(self, other: 'MavenVersion') -> bool:
        return self._compare(other) >= 0

    def __eq__(self, other) -> bool:
        if type(other) == 'MavenVersion':
            return False
        return self._compare(other) == 0
    def __ne__(self, other) -> bool:
        if type(other) == 'MavenVersion':
            return True
        return self._compare(other) != 0
    
    def _compare(self, other: 'MavenVersion') -> int:
        """
        Compare this version with another.
        
        Returns:
            -1 if self < other, 0 if equal, 1 if self > other
        """
        tokens1, tokens2 = self._pad_tokens(other.tokens)
        
        for tok1, tok2 in zip(tokens1, tokens2):
            result = self._compare_token(tok1, tok2)
            if result != 0:
                return result
        
        return 0
    
    def __str__(self) -> str:
        return self.original
    
    def __repr__(self) -> str:
        return f"MavenVersion('{self.original}')"
    
    def __hash__(self) -> int:
        # Hash based on tokens for consistent equality
        return hash(tuple((sep, str(val)) for sep, val in self.tokens))


@dataclass
class VersionSegment:
    """Represents a contiguous range of versions [lower, upper]"""
    lower: Optional[MavenVersion]
    upper: Optional[MavenVersion]
    lower_inclusive: bool
    upper_inclusive: bool
    
    def contains(self, version: MavenVersion) -> bool:
        """Check if a version falls within this segment"""
        if self.lower is not None:
            if self.lower_inclusive:
                if version < self.lower:
                    return False
            else:
                if version <= self.lower:
                    return False
        
        if self.upper is not None:
            if self.upper_inclusive:
                if version > self.upper:
                    return False
            else:
                if version >= self.upper:
                    return False
        
        return True

    def __and__(self, other: 'VersionSegment') -> 'VersionSegment':
        l1, l1i = self.lower, self.lower_inclusive
        l2, l2i = other.lower, other.lower_inclusive
        r1, r1i = self.upper, self.upper_inclusive
        r2, r2i = other.upper, other.upper_inclusive

        l = l1 if l1 and (not l2 or l1 > l2) else l2
        r = r1 if r1 and (not r2 or r1 < r2) else r2
        li = l is not None and (l1i or not l1 or l1 < l) and (l2i or not l2 or l2 < l)
        ri = r is not None and (r1i or not r1 or r1 > r) and (r2i or not r2 or r2 > r)
        return VersionSegment(
                lower = l,
                lower_inclusive=li,
                upper = r,
                upper_inclusive=ri)

    def __bool__(self) -> bool:
        if not self.lower or not self.upper:
            return True
        cmp = self.upper._compare(self.lower)
        if cmp != 0:
            return cmp > 0
        # lower = upper
        return self.lower_inclusive and self.upper_inclusive
    
    def __str__(self) -> str:
        if not self:
            return '()'
        lower_bracket = "[" if self.lower_inclusive else "("
        upper_bracket = "]" if self.upper_inclusive else ")"
        lower_str = str(self.lower) if self.lower is not None else ""
        upper_str = str(self.upper) if self.upper is not None else ""
        return f"{lower_bracket}{lower_str},{upper_str}{upper_bracket}"


class VersionRange:
    """
    Represents a Maven version range requirement.
    
    Syntax:
    - "1.0": Soft requirement for 1.0
    - "[1.0]": Hard requirement for exactly 1.0
    - "(,1.0]": Hard requirement for any version <= 1.0
    - "[1.2,1.3]": Hard requirement for 1.2 <= version <= 1.3
    - "[1.0,2.0)": Hard requirement for 1.0 <= version < 2.0
    - "[1.5,)": Hard requirement for version >= 1.5
    - "(,1.0],[1.2,)": Multiple ranges (version <= 1.0 OR version >= 1.2)

    Note: in this implementation, an empty string "" means empty set,
    and overlapping intervals will not simplified.
    Time complexity is O(n^2)
    """

    soft: Optional[MavenVersion]
    """
    maximum of versions specified by soft requirements
    """
    segments: List[VersionSegment]
    """
    intersection of all hard requirements
    """
    
    def __init__(self, range_spec: str | None):
        """
        Parse a version range specification.
        
        Args:
            range_spec: The version range string
        """
        self.soft = None
        self.segments = []
        if range_spec:
            self._parse(range_spec)
    
    def _parse(self, spec: str):
        """Parse the range specification"""
        if not spec:
            raise ValueError("Empty version range specification")
        
        # Check if it's a soft requirement (no brackets)
        if not any(c in spec for c in "[](),"):
            # Soft requirement
            self.soft = MavenVersion(spec)
            self.segments = [VersionSegment(
                lower=None,
                upper=None,
                lower_inclusive=True,
                upper_inclusive=True,
            )]
            return
        
        # Hard requirement - parse segments
        # Split by comma outside of brackets
        segments_str = self._split_segments(spec)
        
        for seg_str in segments_str:
            seg_str = seg_str.strip()
            if not seg_str:
                continue
            
        for seg_str in segments_str:
            seg_str = seg_str.strip()
            if not seg_str:
                continue
            segment = self._parse_segment(seg_str)
            self.segments.append(segment)
    
    def _split_segments(self, spec: str) -> List[str]:
        """Split the specification into individual segment strings"""
        segments = []
        current = ""
        depth = 0
        
        for char in spec:
            if char in "([":
                depth += 1
                current += char
            elif char in ")]":
                depth -= 1
                current += char
                if depth == 0:
                    segments.append(current)
                    current = ""
            elif char == "," and depth == 0:
                # Separator between segments
                if current.strip():
                    segments.append(current)
                current = ""
            else:
                current += char
        
        if current.strip():
            segments.append(current)
        return segments
    
    def _parse_segment(self, seg: str) -> VersionSegment:
        """Parse a single segment like '[1.0,2.0)' """
        if not seg:
            raise ValueError("Empty segment")
        
        # Determine brackets
        if seg[0] not in "([":
            raise ValueError(f"Invalid segment: {seg} (must start with '[' or '(')")
        if seg[-1] not in ")]":
            raise ValueError(f"Invalid segment: {seg} (must end with ']' or ')')")
        
        lower_inclusive = seg[0] == "["
        upper_inclusive = seg[-1] == "]"
        
        # Extract content
        content = seg[1:-1]
        
        # Split by comma
        parts = content.split(",", 1)
        if len(parts) != 2:
            # Single version hard requirement like [1.0]
            if content.strip():
                version = MavenVersion(content.strip())
                return VersionSegment(
                    lower=version,
                    upper=version,
                    lower_inclusive=True,
                    upper_inclusive=True
                )
            else:
                raise ValueError(f"Invalid segment: {seg}")
        
        lower_str, upper_str = parts
        lower_str = lower_str.strip()
        upper_str = upper_str.strip()
        
        lower = MavenVersion(lower_str) if lower_str else None
        upper = MavenVersion(upper_str) if upper_str else None
        
        return VersionSegment(
            lower=lower,
            upper=upper,
            lower_inclusive=lower_inclusive,
            upper_inclusive=upper_inclusive
        )
    
    def contains(self, version: Union[str, MavenVersion]) -> bool:
        """
        Check if a version satisfies this range requirement.
        
        Args:
            version: Version to check (string or MavenVersion)
            
        Returns:
            True if the version satisfies the range
        """
        if isinstance(version, str):
            version = MavenVersion(version)
        
        # Check if version falls in any segment
        for segment in self.segments:
            if segment.contains(version):
                return True
        
        return False

    def __and__(self, other: 'VersionRange') -> 'VersionRange':
        result = VersionRange(None)
        result.segments = [
            intersection 
            for s1 in self.segments
            for s2 in other.segments
            if (intersection := s1 and s2)
        ]
        s1, s2 = self.soft, other.soft
        result.soft = s1 if s1 and (not s2 or s1 > s2) else s2
        return result

    def __bool__(self):
        return len(self.segments) > 0
    
    def __str__(self) -> str:
        strs = [str(s) for s in self.segments]
        if self.soft:
            strs.append(str(self.soft))
        return ', '.join(strs) if strs else '()'
    
    def __repr__(self) -> str:
        return f"VersionRange('{str(self)}')"
