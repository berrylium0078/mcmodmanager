"""
Minecraft Mod Dependency Checker
Verifies if a list of Minecraft mod files have all dependencies resolved.
Supports: Forge, NeoForge, Fabric, Quilt, LiteLoader, Cauldron
Generated by Claude Sonnet 4.5
"""

import argparse
import json
import zipfile
import toml
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
from dataclasses import dataclass, field
from enum import Enum


class ModLoader(Enum):
    FORGE = "forge"
    NEOFORGE = "neoforge"
    FABRIC = "fabric"
    QUILT = "quilt"
    LITELOADER = "liteloader"
    CAULDRON = "cauldron"


# Special mod IDs that represent the game/loader itself
SPECIAL_MODS = {
    'minecraft',
    'forge',
    'neoforge',
    'fabricloader', 'fabric-loader', 'fabric',
    'quilt_loader', 'quilt',
    'liteloader',
    'cauldron',
    'java',
    'fml'  # Forge Mod Loader
}


@dataclass
class Dependency:
    mod_id: str
    version_range: str = "*"
    mandatory: bool = True
    ordering: str = "NONE"
    is_special: bool = False  # For minecraft, forge, fabric, etc.


@dataclass
class ModInfo:
    mod_id: str
    name: str
    version: str
    loader: ModLoader
    dependencies: List[Dependency] = field(default_factory=list)
    provides: List[str] = field(default_factory=list)
    file_path: Optional[Path] = None
    is_jar_in_jar: bool = False
    parent_mod: Optional[str] = None


class ModParser:
    """Parse mod metadata from various mod loaders"""
    
    @staticmethod
    def parse_mod_file(file_path: Path, extract_nested: bool = True) -> List[ModInfo]:
        """
        Parse a mod JAR file and extract metadata.
        Returns a list of ModInfo (main mod + any nested Jar-in-Jar mods)
        """
        mods = []
        
        try:
            with zipfile.ZipFile(file_path, 'r') as jar:
                # Parse main mod
                main_mod = ModParser._parse_main_mod(jar, file_path)
                if main_mod:
                    mods.append(main_mod)
                
                # Extract and parse nested JARs if enabled
                if extract_nested and main_mod:
                    nested_mods = ModParser._extract_jar_in_jar(jar, file_path, main_mod)
                    mods.extend(nested_mods)
                
        except Exception as e:
            print(f"Error parsing {file_path.name}: {e}")
            return []
        
        return mods

    @staticmethod
    def _parse_main_mod(jar: zipfile.ZipFile, file_path: Path) -> Optional[ModInfo]:
        """Parse the main mod from a JAR file"""
        # Try Forge/NeoForge (mods.toml)
        if 'META-INF/mods.toml' in jar.namelist():
            return ModParser._parse_forge_neoforge(jar, file_path)
        
        # Try Fabric/Quilt (fabric.mod.json)
        if 'fabric.mod.json' in jar.namelist():
            return ModParser._parse_fabric_quilt(jar, file_path)
        
        # Try old Forge (mcmod.info)
        if 'mcmod.info' in jar.namelist():
            return ModParser._parse_old_forge(jar, file_path)
        
        # Try LiteLoader (litemod.json)
        if 'litemod.json' in jar.namelist():
            return ModParser._parse_liteloader(jar, file_path)
        
        print(f"Warning: Unknown mod format for {file_path.name}")
        return None
    
    @staticmethod
    def _extract_jar_in_jar(jar: zipfile.ZipFile, parent_path: Path, parent_mod: ModInfo) -> List[ModInfo]:
        """
        Extract and parse nested JAR files (Jar-in-Jar).
        Common locations:
        - META-INF/jarjar/ (Forge/NeoForge)
        - META-INF/jars/ (Fabric/Quilt)
        """
        nested_mods = []
        parent_name = parent_mod.name if parent_mod else parent_path.stem
        
        # Look for nested JARs in common locations
        nested_jar_paths = []
        for name in jar.namelist():
            if name.endswith('.jar') and (
                name.startswith('META-INF/jarjar/') or
                name.startswith('META-INF/jars/') or
                '/jars/' in name
            ):
                nested_jar_paths.append(name)
        
        if not nested_jar_paths:
            return nested_mods
        
        # Create temp directory for extraction
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            for nested_jar_path in nested_jar_paths:
                try:
                    # Extract nested JAR
                    jar.extract(nested_jar_path, temp_path)
                    extracted_path = temp_path / nested_jar_path
                    
                    # Parse the nested JAR (don't recursively extract more JARs)
                    nested_jar_mods = ModParser.parse_mod_file(extracted_path, extract_nested=False)
                    
                    for nested_mod in nested_jar_mods:
                        nested_mod.is_jar_in_jar = True
                        nested_mod.parent_mod = parent_name
                        nested_mod.file_path = parent_path  # Reference parent file
                        nested_mods.append(nested_mod)
                        
                except Exception as e:
                    print(f"Warning: Failed to parse nested JAR {nested_jar_path}: {e}")
        
        return nested_mods

    @staticmethod
    def _parse_forge_neoforge(jar: zipfile.ZipFile, file_path: Path) -> Optional[ModInfo]:
        """Parse Forge/NeoForge mods.toml"""
        content = jar.read('META-INF/mods.toml').decode('utf-8')
        data = toml.loads(content)
        
        # Determine if it's NeoForge or Forge
        loader_str = data.get('loaderVersion', '')
        loader = ModLoader.NEOFORGE if 'neoforge' in loader_str.lower() else ModLoader.FORGE
        
        # Get first mod entry
        mods = data.get('mods', [])
        if not mods:
            return None
        
        mod = mods[0]
        mod_id = mod.get('modId', 'unknown')
        name = mod.get('displayName', mod_id)
        version = mod.get('version', '0.0.0')
        
        # Parse dependencies
        dependencies = []
        for dep in data.get('dependencies', {}).get(mod_id, []):
            dep_mod_id = dep.get('modId', '')
            dependencies.append(Dependency(
                mod_id=dep_mod_id,
                version_range=dep.get('versionRange', '*'),
                mandatory=dep.get('mandatory', True),
                ordering=dep.get('ordering', 'NONE'),
                is_special=dep_mod_id.lower() in SPECIAL_MODS,
            ))
        
        return ModInfo(
            mod_id=mod_id,
            name=name,
            version=version,
            loader=loader,
            dependencies=dependencies,
            file_path=file_path
        )
    
    @staticmethod
    def _parse_fabric_quilt(jar: zipfile.ZipFile, file_path: Path) -> ModInfo:
        """Parse Fabric/Quilt fabric.mod.json"""
        content = jar.read('fabric.mod.json').decode('utf-8')
        data = json.loads(content)
        
        mod_id = data.get('id', 'unknown')
        name = data.get('name', mod_id)
        version = data.get('version', '0.0.0')
        
        # Check if it's Quilt (has quilt_loader in depends)
        depends = data.get('depends', {})
        loader = ModLoader.QUILT if 'quilt_loader' in depends else ModLoader.FABRIC
        
        # Parse dependencies
        dependencies = []
        for dep_id, dep_version in depends.items():
            dependencies.append(Dependency(
                mod_id=dep_id,
                version_range=dep_version if isinstance(dep_version, str) else '*',
                mandatory=True,
                is_special=dep_id.lower() in SPECIAL_MODS,
            ))
        
        # Parse provides
        provides = data.get('provides', [])
        
        return ModInfo(
            mod_id=mod_id,
            name=name,
            version=version,
            loader=loader,
            dependencies=dependencies,
            provides=provides,
            file_path=file_path
        )
    
    @staticmethod
    def _parse_old_forge(jar: zipfile.ZipFile, file_path: Path) -> ModInfo:
        """Parse old Forge mcmod.info"""
        content = jar.read('mcmod.info').decode('utf-8')
        data = json.loads(content)
        
        if isinstance(data, list):
            data = data[0]
        
        mod_id = data.get('modid', 'unknown')
        name = data.get('name', mod_id)
        version = data.get('version', '0.0.0')
        
        # Parse dependencies
        dependencies = []
        for dep in data.get('requiredMods', []):
            dependencies.append(Dependency(
                mod_id=dep,
                mandatory=True,
                is_special=dep.lower() in SPECIAL_MODS,
            ))
        
        return ModInfo(
            mod_id=mod_id,
            name=name,
            version=version,
            loader=ModLoader.FORGE,
            dependencies=dependencies,
            file_path=file_path
        )
    
    @staticmethod
    def _parse_liteloader(jar: zipfile.ZipFile, file_path: Path) -> ModInfo:
        """Parse LiteLoader litemod.json"""
        content = jar.read('litemod.json').decode('utf-8')
        data = json.loads(content)
        
        mod_id = data.get('name', 'unknown')
        name = data.get('displayName', mod_id)
        version = data.get('version', '0.0.0')
        
        # LiteLoader doesn't typically have complex dependency definitions
        dependencies = []
        for dep in data.get('requiredMods', []):
            dependencies.append(Dependency(
                mod_id=dep,
                mandatory=True,
                is_special=dep.lower() in SPECIAL_MODS,
            ))
        
        return ModInfo(
            mod_id=mod_id,
            name=name,
            version=version,
            loader=ModLoader.LITELOADER,
            dependencies=dependencies,
            file_path=file_path
        )


class DependencyChecker:
    """Check if all mod dependencies are satisfied"""
    
    def __init__(self, mods: List[ModInfo]):
        self.mods = mods
        self.mod_map: Dict[str, ModInfo] = {}
        self.special_requirements: Dict[str, List[Tuple[str, str]]] = {}  # special_mod_id -> [(mod_name, version_range)]
        self._build_mod_map()
        self._collect_special_requirements()
    
    def _build_mod_map(self):
        """Build a map of mod_id -> ModInfo"""
        for mod in self.mods:
            self.mod_map[mod.mod_id] = mod
            # Also add provides
            for provided_id in mod.provides:
                self.mod_map[provided_id] = mod
    
    def _collect_special_requirements(self):
        """Collect all requirements for special mods (minecraft, forge, etc.)"""
        for mod in self.mods:
            for dep in mod.dependencies:
                if dep.is_special and dep.mandatory:
                    if dep.mod_id not in self.special_requirements:
                        self.special_requirements[dep.mod_id] = []
                    self.special_requirements[dep.mod_id].append((mod.name, dep.version_range))

    def check_dependencies(self) -> Tuple[bool, List[str]]:
        """
        Check if all dependencies are satisfied.
        Returns (all_satisfied, list_of_issues)
        """
        issues = []
        all_satisfied = True
        
        for mod in self.mods:
            for dep in mod.dependencies:
                if dep.is_special or not dep.mandatory:
                    continue  # Skip special mods and optional deps
                
                if dep.mod_id not in self.mod_map:
                    all_satisfied = False
                    issues.append(
                        f"❌ {mod.name} ({mod.mod_id}) requires {dep.mod_id} {dep.version_range} - NOT FOUND"
                    )
                else:
                    # Dependency found
                    dep_mod = self.mod_map[dep.mod_id]
                    issues.append(
                        f"✓ {mod.name} ({mod.mod_id}) requires {dep.mod_id} - found v{dep_mod.version}"
                    )
        
        return all_satisfied, issues
    
    def get_special_requirements_summary(self) -> List[str]:
        """
        Get a summary of special mod requirements (minecraft, forge, etc.)
        Shows the intersection of all version ranges required by mods.
        """
        summary = []
        
        for special_mod_id in sorted(self.special_requirements.keys()):
            requirements = self.special_requirements[special_mod_id]
            
            summary.append(f"\n{special_mod_id.upper()}:")
            
            # Group by version range and show which mods require each
            version_groups: Dict[str, List[str]] = {}
            for mod_name, version_range in requirements:
                if version_range not in version_groups:
                    version_groups[version_range] = []
                version_groups[version_range].append(mod_name)
            
            # Show all unique version requirements
            for version_range in sorted(version_groups.keys()):
                mod_names = version_groups[version_range]
                if len(mod_names) <= 3:
                    mods_str = ", ".join(mod_names)
                else:
                    mods_str = f"{', '.join(mod_names[:3])} and {len(mod_names) - 3} more"
                
                summary.append(f"  {version_range} - required by {mods_str}")
            
            # If there are multiple different version requirements, note potential conflict
            if len(version_groups) > 1:
                summary.append(f"  ⚠️  Multiple version requirements detected - ensure compatibility!")
        
        return summary

    def get_missing_dependencies(self) -> Set[str]:
        """Get set of missing dependency mod IDs (excluding special mods)"""
        missing = set()
        for mod in self.mods:
            for dep in mod.dependencies:
                if dep.mandatory and not dep.is_special and dep.mod_id not in self.mod_map:
                    missing.add(dep.mod_id)
        return missing


def execute(args):
    # Parse all mods
    mods = []
    for mod_file in args.mods:
        print(f"Parsing {mod_file}...", end=' ')
        mod_info = ModParser.parse_mod_file(mod_file)
        mods += mod_info

    for mod_info in mods:
        print(f"{mod_info.name} {mod_info.version} ({mod_info.loader.value})")
    
    print(f"\nSuccessfully parsed {len(mods)} mod(s)\n")
    
    if args.mod_info:
        print("=" * 60)
        print("MOD LIST")
        print("=" * 60)
        for mod in mods:
            prefix = "  └─ " if mod.is_jar_in_jar else ""
            print(f"\n{prefix}{mod.name}")
            print(f"{prefix}  ID: {mod.mod_id}")
            print(f"{prefix}  Version: {mod.version}")
            print(f"{prefix}  Loader: {mod.loader.value}")
            if mod.is_jar_in_jar:
                print(f"{prefix}  Source: Jar-in-Jar from {mod.parent_mod}")
            else:
                print(f"{prefix}  File: {mod.file_path.name}")
            if mod.dependencies:
                print(f"{prefix}  Dependencies:")
                for dep in mod.dependencies:
                    mandatory = "mandatory" if dep.mandatory else "optional"
                    print(f"{prefix}    - {dep.mod_id} {dep.version_range} ({mandatory})")
        print()
    
    # Check dependencies
    checker = DependencyChecker(mods)
    all_satisfied, issues = checker.check_dependencies()
    
    print("=" * 60)
    print("DEPENDENCY CHECK RESULTS")
    print("=" * 60)
    
    # Show special mod requirements (minecraft, forge, etc.)
    special_summary = checker.get_special_requirements_summary()
    if special_summary:
        print("\nSPECIAL MOD REQUIREMENTS (Minecraft, Forge, etc.):")
        print("=" * 60)
        for line in special_summary:
            print(line)
        print()
    
    # Show regular dependency checks
    if args.verbose or not all_satisfied:
        print("REGULAR MOD DEPENDENCIES:")
        print("=" * 60)
        for issue in issues:
            print(issue)
        print()
    
    missing = checker.get_missing_dependencies()
    
    if all_satisfied:
        print("✓ All mandatory dependencies are satisfied!")
        return 0
    else:
        print(f"❌ Missing {len(missing)} required mod(s):")
        for mod_id in sorted(missing):
            print(f"  - {mod_id}")
        print("\nPlease install the missing mods to resolve dependencies.")
        return 1

def addparser(subparsers):
    parser: argparse.ArgumentParser
    parser = subparsers.add_parser('health', help='Verify Minecraft mod dependencies')
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Show detailed dependency information'
    )
    parser.add_argument(
        '-i', '--mod-info',
        action='store_true',
        help='List all detected mods and their info'
    )
    parser.add_argument('mods', nargs='+', help='Mod list')
    parser.set_defaults(func=execute)
