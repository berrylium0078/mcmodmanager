"""
Minecraft Mod Dependency Checker
Verifies if a list of Minecraft mod files have all dependencies resolved.
Supports: Forge, NeoForge, Fabric, Quilt, LiteLoader, Cauldron
Generated by Claude Sonnet 4.5
"""

import argparse
from pathlib import Path
from typing import List, Dict, Tuple, Set
from src.lib.version import MavenVersion, VersionRange
from src.lib.jarparser import ModInfo, ModParser

class DependencyChecker:
    """Check if all mod dependencies are satisfied"""
    
    def __init__(self, mods: List[ModInfo]):
        self.mods = mods
        self.mod_map: Dict[str, ModInfo] = {}
        self.special_requirements: Dict[str, List[Tuple[str, str]]] = {}  # special_mod_id -> [(mod_name, version_range)]
        self._build_mod_map()
        self._collect_special_requirements()
    
    def _build_mod_map(self):
        """Build a map of mod_id -> ModInfo"""
        for mod in self.mods:
            self.mod_map[mod.mod_id] = mod
            # Also add provides
            for provided_id in mod.provides:
                self.mod_map[provided_id] = mod
    
    def _collect_special_requirements(self):
        """Collect all requirements for special mods (minecraft, forge, etc.)"""
        for mod in self.mods:
            for dep in mod.dependencies:
                if dep.is_special and dep.mandatory:
                    if dep.mod_id not in self.special_requirements:
                        self.special_requirements[dep.mod_id] = []
                    self.special_requirements[dep.mod_id].append((mod.name, dep.version_range))

    def check_dependencies(self) -> Tuple[List[str], List[str]]:
        """
        Check if all dependencies are satisfied.
        Returns (all_satisfied, list_of_issues)
        """
        issues = []
        info = []
        
        for mod in self.mods:
            for dep in mod.dependencies:
                if dep.is_special or not dep.mandatory:
                    continue  # Skip special mods and optional deps
                
                if dep.mod_id not in self.mod_map:
                    issues.append(
                        f"❌ {mod.name} ({mod.mod_id}) requires {dep.mod_id} {dep.version_range} - NOT FOUND"
                    )
                else:
                    # Dependency found
                    dep_mod = self.mod_map[dep.mod_id]
                    try:
                        version_range = VersionRange(dep.version_range)
                        dep_version = MavenVersion(dep_mod.version)
                        
                        if version_range.contains(dep_version):
                            info.append(
                                f"✓ {mod.name} ({mod.mod_id}) requires {dep.mod_id} {dep.version_range} - found v{dep_mod.version}"
                            )
                        else:
                            issues.append(
                                f"❌ {mod.name} ({mod.mod_id}) requires {dep.mod_id} {dep.version_range} - found v{dep_mod.version} (INCOMPATIBLE)"
                            )
                    except Exception:
                        # Fallback if version parsing fails
                        issues.append(
                            f"⚠️  {mod.name} ({mod.mod_id}) requires {dep.mod_id} {dep.version_range} - found v{dep_mod.version} (cannot verify)"
                        )
        
        return info, issues
    
    def get_special_requirements_summary(self, verbose = False) -> List[str]:
        """
        Get a summary of special mod requirements (minecraft, forge, etc.)
        Shows the intersection of all version ranges required by mods.
        """
        summary = []
        
        for special_mod_id in sorted(self.special_requirements.keys()):
            requirements = self.special_requirements[special_mod_id]
            
            summary.append(f"\n{special_mod_id.upper()}:")
            
            # Compute intersection of all version ranges
            try:
                combined_range = None
                for mod_name, version_range_str in requirements:
                    version_range = VersionRange(version_range_str)
                    if combined_range is None:
                        combined_range = version_range
                    else:
                        combined_range = combined_range and version_range
                
                if combined_range:
                    summary.append(f"  Required version: {combined_range}")
                else:
                    summary.append(f"  ❌ NO COMPATIBLE VERSION (conflicting requirements)")
                
                if verbose:
                    # Show individual requirements
                    summary.append(f"  Individual requirements:")
                    version_groups: Dict[str, List[str]] = {}
                    for mod_name, version_range in requirements:
                        if version_range not in version_groups:
                            version_groups[version_range] = []
                        version_groups[version_range].append(mod_name)
                    
                    for version_range in sorted(version_groups.keys()):
                        mod_names = version_groups[version_range]
                        if len(mod_names) <= 3:
                            mods_str = ", ".join(mod_names)
                        else:
                            mods_str = f"{', '.join(mod_names[:3])} and {len(mod_names) - 3} more"
                        
                        summary.append(f"    {version_range} - {mods_str}")
                    
                    # If there are conflicts
                    if combined_range and not combined_range:
                        summary.append(f"  ⚠️  CONFLICT: No version satisfies all requirements!")
                    elif len(version_groups) > 1:
                        summary.append(f"  ℹ️  Multiple requirements - using intersection")
            
            except Exception as e:
                summary.append(f"  ⚠️  Error computing version intersection: {e}")
                # Fallback to simple listing
                for mod_name, version_range in requirements:
                    summary.append(f"    {version_range} - {mod_name}")
        
        return summary

    def get_missing_dependencies(self) -> Set[str]:
        """Get set of missing dependency mod IDs (excluding special mods)"""
        missing = set()
        for mod in self.mods:
            for dep in mod.dependencies:
                if dep.mandatory and not dep.is_special and dep.mod_id not in self.mod_map:
                    missing.add(dep.mod_id)
        return missing


def execute(args):
    # Parse all mods
    mods = []
    for mod_file in args.mods:
        if args.verbose:
            print(f"Parsing {mod_file}...")
        mod_info = ModParser.parse_mod_file(Path(mod_file))
        mods += mod_info

    print(f"\nSuccessfully parsed {len(mods)} mod(s)\n")
    
    if args.mod_info:
        print("=" * 60)
        print("MOD LIST")
        print("=" * 60)

        bucket: Dict[str,int] = {}
        for mod in mods:
            if mod.mod_id in bucket:
                bucket[mod.mod_id] += 1
            else:
                bucket[mod.mod_id] = 0

        for mod in mods:
            if bucket[mod.mod_id] > 1 and not mod.is_jar_in_jar:
                print(f"Warning: duplicate mod {mod.name} {mod.file_path.name}")

            prefix = "  └─ " if mod.is_jar_in_jar else ""
            print(f"\n{prefix}{mod.name}")
            print(f"{prefix}  ID: {mod.mod_id}")
            print(f"{prefix}  Version: {mod.version}")
            print(f"{prefix}  Loader: {mod.loader.value}")
            if mod.is_jar_in_jar:
                print(f"{prefix}  Source: Jar-in-Jar from {mod.parent_mod}")
            else:
                print(f"{prefix}  File: {mod.file_path.name}")
            if mod.dependencies:
                print(f"{prefix}  Dependencies:")
                for dep in mod.dependencies:
                    mandatory = "mandatory" if dep.mandatory else "optional"
                    print(f"{prefix}    - {dep.mod_id} {dep.version_range} ({mandatory})")
        print()
    
    # Check dependencies
    checker = DependencyChecker(mods)
    info, issues = checker.check_dependencies()

    print("=" * 60)
    print("DEPENDENCY CHECK RESULTS")
    print("=" * 60)
    
    # Show special mod requirements (minecraft, forge, etc.)
    special_summary = checker.get_special_requirements_summary(args.verbose)
    if special_summary:
        print("\nSPECIAL MOD REQUIREMENTS (Minecraft, Forge, etc.):")
        print("=" * 60)
        for line in special_summary:
            print(line)
        print()
    
    # Show regular dependency checks
    if issues or (args.verbose and info):
        print("REGULAR MOD DEPENDENCIES:")
        print("=" * 60)
        for issue in (issues + info if args.verbose else issues):
            print(issue)
        print()
    
    missing = checker.get_missing_dependencies()
    
    if not issues:
        print("✓ All mandatory dependencies are satisfied!")
        return 0
    elif missing:
        print(f"❌ Missing {len(missing)} required mod(s):")
        for mod_id in sorted(missing):
            print(f"  - {mod_id}")
        print("\nPlease install the missing mods to resolve dependencies.")
        return 1

def addparser(subparsers):
    parser: argparse.ArgumentParser
    parser = subparsers.add_parser('health', help='Verify Minecraft mod dependencies')
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Show detailed dependency information'
    )
    parser.add_argument(
        '-i', '--mod-info',
        action='store_true',
        help='List all detected mods and their info'
    )
    parser.add_argument('mods', nargs='+', help='Mod list')
    parser.set_defaults(func=execute)
